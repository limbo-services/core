// Code generated by protoc-gen-gogo.
// source: limbo.services/core/runtime/limbo/authz.proto
// DO NOT EDIT!

package limbo

import proto "limbo.services/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "limbo.services/protobuf/gogoproto"

import strings "strings"
import limbo_services_protobuf_proto "limbo.services/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AuthzRule struct {
	// Path to caller identifier.
	Caller string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	// Path to context identifier.
	Context string `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
	// Scope that give permission to call the RPC
	Scope string `protobuf:"bytes,3,opt,name=scope,proto3" json:"scope,omitempty"`
}

func (m *AuthzRule) Reset()                    { *m = AuthzRule{} }
func (m *AuthzRule) String() string            { return proto.CompactTextString(m) }
func (*AuthzRule) ProtoMessage()               {}
func (*AuthzRule) Descriptor() ([]byte, []int) { return fileDescriptorAuthz, []int{0} }

func (this *AuthzRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&limbo.AuthzRule{")
	s = append(s, "Caller: "+fmt.Sprintf("%#v", this.Caller)+",\n")
	s = append(s, "Context: "+fmt.Sprintf("%#v", this.Context)+",\n")
	s = append(s, "Scope: "+fmt.Sprintf("%#v", this.Scope)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAuthz(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringAuthz(e map[int32]limbo_services_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func init() {
	proto.RegisterType((*AuthzRule)(nil), "limbo.AuthzRule")
}

var fileDescriptorAuthz = []byte{
	// 169 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xd2, 0xcd, 0xc9, 0xcc, 0x4d,
	0xca, 0xd7, 0x2b, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0x2d, 0xd6, 0x4f, 0xce, 0x2f, 0x4a, 0xd5,
	0x2f, 0x2a, 0xcd, 0x2b, 0xc9, 0xcc, 0x4d, 0xd5, 0x07, 0xcb, 0xe9, 0x27, 0x96, 0x96, 0x64, 0x54,
	0xe9, 0x15, 0x14, 0xe5, 0x97, 0xe4, 0x0b, 0xb1, 0x82, 0x85, 0xa4, 0x74, 0xd0, 0x74, 0x81, 0x25,
	0x93, 0x4a, 0xd3, 0xf4, 0xd3, 0xf3, 0xd3, 0xf3, 0xc1, 0x1c, 0x30, 0x0b, 0xa2, 0x49, 0x29, 0x92,
	0x8b, 0xd3, 0x11, 0x64, 0x46, 0x50, 0x69, 0x4e, 0xaa, 0x90, 0x18, 0x17, 0x5b, 0x72, 0x62, 0x4e,
	0x4e, 0x6a, 0x91, 0x04, 0xa3, 0x02, 0xa3, 0x06, 0x67, 0x10, 0x94, 0x27, 0x24, 0xc1, 0xc5, 0x9e,
	0x9c, 0x9f, 0x57, 0x92, 0x5a, 0x51, 0x22, 0xc1, 0x04, 0x96, 0x80, 0x71, 0x85, 0x44, 0xb8, 0x58,
	0x8b, 0x93, 0xf3, 0x0b, 0x52, 0x25, 0x98, 0xc1, 0xe2, 0x10, 0x8e, 0x15, 0xcb, 0x86, 0x05, 0xf2,
	0x8c, 0x4e, 0xec, 0x51, 0x10, 0x17, 0x25, 0xb1, 0x81, 0xad, 0x32, 0x06, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x45, 0x91, 0xe9, 0x59, 0xd0, 0x00, 0x00, 0x00,
}
